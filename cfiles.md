# Системни примитиви за работа с файлове в Linux

## компилиране  на C програма

**cc -o file.exe file.c**

gcc или cc за рънване / рънване на файл и изписва грешките
създава се ./a.out 
и пускаме него евентуално с параметри да го ръннем

## Файлов дескриптор
Неотрицателно цяло число, което служи за уникален идентификатор на отворен файл. Файловите дескриптори имат локално значение за процесите – всеки процес разполага с N файлови дескриптора. Всеки процес стандартно има отворени три дескриптора:

•	0 (стандартен вход)

•	1 (стандартен изход)

•	2 (стандартен изход за грешки)

## Отваряне и създаване на файл

**#include <fcntl.h>**
int open(const char *filename, int oflag [, mode_t mode]);

•	Отваря файл с име filename в режим oflag, а ако не съществува го създава с режим mode.

•	връща файлов дескриптор, с който се работи в програмата или -1 при неуспех

oflag указва режима на отваряне и/или действия, които да се извършат след отваряне:

•	O_RDONLY - само за четене

•	O_WRONLY - само за писане

•	O_RDWR - за четене и писане

•	O_CREAT - създава файла ( ако не съществува се създава трябва задължително права за достъп)

•	O_EXCL - заедно с O_CREAT: ако файлът не съществува, той се създава, иначе се връща грешка

•	O_TRUNC - старото съдържание на файла се изтрива след отваряне

•	O_APPEND - старото съдържание се запазва, а новото се вписва в края на файла

## Четене от файл

**#include <unistd.h>**
ssize_t read(int fd, void *buf, size_t nbytes);
  
•	fd - номер на файлов дескриптор

•	buf - указател към областта от програмата, където се записват данните

•	nbytes - указва броя байтове за четене

•	връща броя на реално прочетените байтове, иначе връща -1

•	при край на файл – 0
(не можем да четем от файл за писане !!!)

## Писане във файл

ssize_t write(int fd, void *buf, size_t nbytes);

•	fd - номер на файлов дескриптор

•	buf - указател към областта от програмата, където се записват данните

•	nbytes - указва броя байтове за писане

•	връща броя на реално записаните байтове, иначе връща -1

## Позициониране във файл

off_t lseek(int fd, off_t offset, int whence);

•	fd - номер на файлов дескриптор

•	offset - самото отместване

•	whence - указва как се интерпретира отместването

o	SEEK_SET - премества указателя от началото до offset-байта

o	SEEK_CUR - премества указателя от сегашната му позиция до offset-байта

o	SEEK_END - премества указателя от края на файла (отзад-напред) до offset-байта (отрицателно число)

## Затваряне на файл
int close(int fd);

## Дублиране на файлов дескриптор

int dup(int oldfd) - дублира файлов дескриптор на първото свободно място

int dup2(int oldfd, int newfd) - дублира файлов дескриптор с посочения

# Main

int main (int argc, char* argv[])

{

	return 0;
 
}

argv[0] –винаги е запазено за програмата параметрите са от 1 ...

ако пише подават се като параметри се намират в argv[1] … argv[n]

argc броят на парамерите 

# Системни примитиви за работа с процеси

Адресното пространство на всеки процес се състои от три сегмента – програмен, данни и стек. 
Процесите могат да създават други процеси, като оригиналният процес се нарича родител, а новосъздадения се нарича дете. Един родител може да има много процеси-деца, но едно дете може да има най-много един родител. По този начин се създават йерархични групи от процеси, които могат да комуникират помежду си и да споделят ресурси.

## Създаване на процес-дете – системен примитив fork()

#include <sys/types.h>  

#include <unistd.h>  

pid_t fork(void);

След изпълняване на fork() имаме два процеса - съществуващия (създал детето) се нарича родител, а новосъздадения е процесът-дете.  Новосъздаденият процес използва заедно с родителя си програмния сегмент, а сегмент данни и стек се копират от родителя в момента на създаването т.е. детето унаследява всичките променливи, отворени файлове и въобще всички данни съществуващи в родителя.  И след това всеки процес се развива самостоятелно.
fork() връща:
•	-1 при неуспешно създаване на процес-дете

•	0 за процес-дете

•	pid на новосъздадения процес-дете в родителя




След като сме изпълнили fork() от тук-нататък  кода, който сме написали се изпълнява и от родителя и от детето.
Пример:
#include  <stdio.h> 

#include  <sys/types.h>  

#include  <unistd.h>  

int main() { 

	printf("Hello there!");
 
	fork(); 
 
	printf("Called fork()");
 
	return  0; 
 
}

Кой се изпълнява първи - родителя или детето?
Всеки път различно - и двата процеса работят асинхронно.
Как да направим така, че да има код, който ще се изпълни само от родителя/детето?
Използваме резултатът от fork().

## Получаване на pid за процесът-дете и процесът-родител – getpid(); getppid()
#include <sys/types.h>


#include <unistd.h>  

pid_t getpid(void);

Дава ни pid-то на текущия процес.

#include <sys/types.h>  

#include <unistd.h>  

pid_t getppid(void);

Дава ни pid-то на процесът-родител на съответния процес.

## Завършване на процес - exit()

#include <stdlib.h>

void exit(int return_code);

•	прекратява процеса, който е извикал примитива незабавно.

•	параметърът return_code указва на процесът-родител с какъв код е завършил процеса.

•	системния примитив не връща нищо

•	Всички отворени входни-изходни потоци, притежание на процеса, се затварят, унищожават се временните файлове, създадени от процеса, процесите-деца на текущия процес стават деца на init процеса

## Системен примитив wait()

#include <sys/types.h>

#include <wait.h>


pid_t wait(int * status);

•	чрез wait() процеса-родител изчаква своето дете да приключи.

•	примитива връща pid на завършилия процес-дете.

•	status параметъра ни дава кода на завършване на процесът-дете.

•	ако има wait в детето без то да е родител не става нищо


Допълнителна информация: Чрез wait() процеса-родител изчаква първото дете, което завършва. 

## Чрез waitpid() ние можем да кажем на родителя кой специфичен процес-дете да изчака.

#include <sys/types.h>

#include <wait.h>

pid_t waitpid(pid_t pid, int * status, int options);


•	чрез pid указваме кой процес-дете да чака родителя:

•	status параметъра ни дава кода на завършване на процесът-дете.

•	чрез options може да се предотврати блокирането на родителя. При значение WHOHANG процесът-родител не се блокира, ако синът не е завършил и функцията връща 0.

•	функцията връща pid на завършилия процес-дете.

# Смяна на образ на процес – exec()

exec се използва за промяна на програмата, която един процес изпълнява. При успех еxec не връща нищо, иначе връща -1. Той има няколко варианта:

#include <unistd.h>

int execv(const char *path, char *const argv[]);

int execvp (const char *file, char *const argv[]);

•	И двете фунции приемат масив от параметри на изпълнимия файл.

•	execv приема пътя до изпълнимия файл

•	еxecvp приема името на изпълнимия файл и я търси в директориите, които са зададени в PATH системната променлива


#include <unistd.h>

int  execl(const char *path, const char *arg, ...)

int  execlp(const char *file, const char *arg, ...)

•	И двете функции приемат параметри на изпълнимия файл, изброени един по един

•	execl приема пътя до изпълнимия файл

•	еxeclp приема името на изпълнимия файл и я търси в директориите, които са зададени в PATH системната променлива


